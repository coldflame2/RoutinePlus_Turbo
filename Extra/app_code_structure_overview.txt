'Routine Plus Turbo' is a productivity tool designed for Windows, developed using PyQt6 bindings with a
Model-View-Controller (MVC) architecture.

Core Functionality:
The application displays a daily routine in a tabular format.
Each row in the table represents a task with columns for start time, end time, duration, task name, and a reminder.
Special hidden columns for internal use include 'id', 'type', and 'position'.
Tasks are divided into 'main tasks' and 'QuickTask'.

Time Management:
The table is structured to cover a full 24-hour period, starting and ending at midnight.
Tasks are listed sequentially without gaps, ensuring the total duration adds up to 24 hours.

Software Structure:
Main Modules: main.py, main_window.py, table_view.py, table_model.py, app_data.py, left_bar.py, controller.py.
Key Classes: MainApp (QApplication), MainWindow (QMainWindow), TableView (QTableView), TableModel (QAbstractItemModel), AppData, LeftBar (QObject), Controller.
Supplementary Components: Processor (for Controller class), TaskerModel and AutoTimeUpdater (for TableModel
class).

Class Functionalities:
MainApp: Manages the main application.

MainWindow: Handles layout, widget integration including TableView and LeftBar.

TableView: Manages the table view, delegates, and signal-slot connections.

TableModel: Provides data for the view and Controller, manages database interactions. TaskerModel assists in
task management. There's also AutoTimeUpdater, to auto-update the table when the time changes.

Controller: Intercepts signals from MainWindow and LeftBar, utilizes Processor functions, updates the table
via TableModel methods. Processor (a helper class) handles various logic and data processing, like getting
selected row index, calculating data for new row, checking the validity before adding or deleting, etc. It
doesn't cause any changes to the table directly.

AppData: Manages the SQLite Database, handles datetime conversions, and offers helper functions.
LeftBar: Provides a navigational and task-oriented interface, emitting signals upon user interaction.

Tree structure of the app is as follows:
src (parent directory)
├── main.py
├── models
│   ├── app_data.py
│   └── table_model.py
|   └── tasker_model.py
|   └── auto_time_updater.py
├── controllers
│   ├── controller.py
│   └── processor.py
└── views
│   ├── delegates
│   │   └── table_delegate.py
│   ├── left_bar.py
│   ├── main_window.py
│   ├── ribbon.py
│   ├── table_view.py
│   └── title_bar.py
├── dev
│   ├── build.py
│   ├── environment.py
├── resources
│   ├── default.py
│   ├── icons (Directory)
│   └── styles (Directory)
├── utils
│   ├── app_logging.py
│   ├── helper_fn.py
├── hooks
│   └── hook-plyer.py

Flow of events on new row addition and deletion:
1. Left bar triggers a signal after user interaction.
2. Signal is intercepted by MainWindow, which emits/forwards it, and is then intercepted again by Controller.
3. Controller calls Processor functions to process the data (and to check validity of selected row, etc.).
4. Processor returns the processed data to Controller.
5. Controller calls TaskerModel methods with the processed data to update the table.
6. It also calls AutoTimeUpdater to update the table after tasks are added or deleted.

Flow of events when value edited in table:
1. Editing triggers setData() in TableModel.
2. TableModel calls TaskerModel methods to validate and format the new edited value.
3. TableModel retrieves the returned value and passes on to the AutoTimeUpdater.
4. AutoTimeUpdater prepares the new data for updating the table and returns back to the model.
5. TableModel finally updates both the edited cell and other interdependent cells.

Flow of events when new task is added:
1. Left bar triggers a signal after user interaction, caught by MainWindow and Controller.
2. Controller calls is_valid_task_row() from Processor to check if the selected row is valid for adding a new task.
4. If valid, it calls calculate_new_task_data() from Processor to calculate the data for the new task.
5.



















